*简介:
 预处理命令包括:宏定义(#define,#undef)、文件包含(#include)、条件编译(#if,#ifdef,#ifndef)。编译命令包括:(#loadall,#secret,#loaddata,#code,#begin,#end,#skip,#attr)。
*宏定义:
 用一个指定的标识符(即名字)来代表一个字符串，它的一般形式为:
 #define 标识符 字符串
 如:
 #define CR_KEY 13
 它的作用是指定用标志符CR_KEY来代替"13"这个字符串，在编译预处理时，将程序中在该命令以后出现的所有CR_KEY都用"13"代替。这种方法使用户能以一个简单的名字代替一个长的字符串，因此把这个标识符(名字)称为"宏名"，在预编译时将宏名替换成字符串的过程称为"宏展开"。#define时宏定义命令。
*注意:
 1.宏名一般习惯用大写字母表示，以便与变量名相区别。但这并非规定，也可用小写字母。
 2.使用宏名代替一个字符串，可以减少程序中重复书写某些字符串。如:如果不定义PI代表3.1415926，则在程序中要多处出现3.1415926，不仅麻烦而且容易写错，用宏名代替，简单不易出错，容易记忆而且提高程序的通用性。
 3.宏定义是用宏名代替一个字符串，也就是做简单的体锻，不做正确性检查，这一点要注意。如:
  #define PI 3.1415926
  中的1写成l:
  #define PI 3.l4l5926
  预处理时也照样替换，也就是说预处理时不做任何语法检查，只有在编译时才会发现错误。
 4.宏定义不是语句，不必在行末加;号。如果加了;号则会连;号一起进行替换。如:
  #define P 3;
  s=P*r*r;
  经过宏展开后，该语句为:s=3;*r*r;显然出现语法错误。
 5.#define命令可以出现在程序的任意位置，宏名的有效范围为定义命令之后到源程序结束。通常#define命令写在文件开头，函数之前。
 6.可以用#undef命令终止宏定义的作用域。如:
#define A abs()─
void e()       ↑
{......    A的有效范围
}              ↓
#undef CLR     ─
  由于#undef的作用，使A的作用范围在#undef行处终止，这样可以灵活控制宏定义的作用范围。
 7.在宏定义时，可以引用已定义的宏名，可以层层替换。如:
#define R 3
#define PI 3
#define L 2*PI*R
#define S PI*R*R
 8.对程序中用"号括起来的字符串内的字符，即使与宏名相同也不进行替换。
 9.宏定义是预处理命令，与定义变量的含义不用，只作字符串替换，不分配内存空间。
 10.该预处理器不允许定义带参数的宏。如
#define P(a,b) printf("%d,%d",a,b)
 是错误的。
*文件包含:
 所谓文件包含是指一个源程序可以将另外一个文件的全部内容包含进来，即将另外的文件包含到本文件之中。预处理器提供了#include命令来实现文件包含，其一般形式为:
 #include "文件名"
 或
 #include <文件名>
 在编译预处理时，要对#include命令进行文件包含处理:将指定的文件的全部内容复制插入到#include命令处，将包含以后的源程序作为一个源程序单位进行编译。这个命令可以节省程序设计的重复劳动，减少编译时间。
*注意:
 1.使用""在用户代码目录中搜索，<>在缺省目录(*.h对应/FunData，*.y对应/LibData)中搜索。
 2.只能包含头文件(*.h)或链接库文件(*.y)，文件名可以用路径，但是包含*.y时路径长度<16B，包含*.h时路径长度<19B，一个#include命名只能包含一个指定的文件，如果要包含n个文件，要用n个#include命令。
 3.在有该命令的源程序时作为一个文件编译的(被包含的文件与其源程序文件在预处理后已成为同一个文件)，最后编译生成一个目标文件。
 4.连接库相关信息请参考'帮助'→'简介'→'连接库系统'。
*条件编译:
 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是条件编译。
 条件编译命令有以下几种格式:
 1.#ifdef 标识符
    程序段1
   #else
    程序段2
   #endif
   它的作用是当指定的标识符已经被#define命令定义过，则在程序预处理阶段只处理程序段1，否则处理程序段2。其中#else部分可以没有，即:
   #ifdef 标识符
    程序段1
   #endif
   也可以
   这里的程序段可以时语句，也可以时命令。这种条件编译对于提高源程序通用性是很有好处的。如:在调试程序时，常常希望输出一些所需的信息，而在调试完成后不再输出这些信息。可以在源程序中插入以下的条件编译段:
   #ifdef DEBUG
    printf("x:%d y:%d\n",x,y);
   #endif
   如果在它的前面有以下命令:
   #define DEBUG 0
   则在程序运行时输入x，y的值，以便调试时分析，调试完成后只需去除#define命令即可。
 2.#ifndef 标识符
    程序段1
   #else
    程序段2
   #endif
   只是第一行与第一种形式不同，它的作用刚好与第一种相反:若标识符未被定义过则处理程序段1，否则处理程序段2。
 3.#if 常量表达式
    程序段1
   #else
    程序段2
   #endif
  它的作用是当常量表达式为真(就是非0)时，，则在程序预处理阶段只处理程序段1，否则处理程序段2。
 以上三种形式用法一样，根据需要任选一种。
*注意:
 #ifdef,#ifndef,#if命令可以出现在程序的任意位置并且可以嵌套使用(使用方法和if一样)，例如:
#define XX 1

#if XX == 3 && ((1 - 4) * 5)
# ifdef XX
#  ifndef YY
#   define ZZ 2
#  else if XX == 3
#   define ZZ 3
#  else ifdef XX == 4
#   define ZZ 4
#  else
#   define ZZ 5
#  endif
# endif
#endif

*编译命令:
 除了有预处理命令外还有一种叫编译命令。预处理命令由预处理器处理，而编译命令是由编译器处理。
*#loadall:作用是将程序在运行时全部载入内存中，这样可以加快程序的运行速度。LavaX程序是虚拟运行的，执行一个程序并不是将程序都载入到内存(由一个小的缓冲区)，这对程序的运行速度有影响，而使用这个命令会把程序全部载入内存中，加快了运行速度，所以尽量多使用这个命令。
*注意:
 1.该命令可以出现在源程序的任意地方，但是最好写在文件头部，在头文件中不能出现该命令，出现了也没有效果。
 2.必须保证程序的长度加上程序所用内存不得超出LavaX可用的最大内存(如TC800 LavaX可用的最大内存为24K)。
*#secret:作用是加密程序中出现的临时字符串(不包括用于变量定义的字符串)，使得程序代码无法查看到真实的字符串，起到保密作用！
 该命令的格式是:
 #secret 数字
 如:
 #secret 0x55
 这个数字是密钥，给程序的临时字符串加密，程序执行时在根据这个数字解密。
*注意:
 1.该命令只能出现在程序可以执行的地方(如:源程序头部，函数内部)，否则程序会出现错误！切记！
 2.在链接库中也可以使用该命令。
 3.该命令只能加密临时字符串(如:strcpy(s, "abc");中的"abc"就是临时字符串)，对于定义的字符串(如:数组定义的字符串:char s[] = "abc";或#loaddata定义的字符串:#loaddata s = "abc";都是定义的字符串)没有加密。
*#loaddata，初始化内存。格式是:
 格式1:#loaddata 全局变量或数字=数字或字符串;
  如:
  int a;
  char s[20];
  #loaddata a=-3;
  #loaddata s="Hello World!";
  #loaddata 0x4000=1;//用数字做地址时(比如这里的0x4000，赋值的数字(比如这里的1)不能超过255)
 格式2:#loaddata 全局变量或数字={数字或字符串,数字或字符串,.....};
  如:
  int s[20];
  #loaddata s={-1,2000,30,50,6000};
  #loaddata 0x4000={1,2,3,6};//用数字做地址时(比如这里的0x4000，赋值的数字(比如这里的1)不能超过255)
  char r[10][10];
  #loaddata r={"TC800","NC3000","PC2000"};
 格式3:#loaddata 全局变量或数字=load(路径,数字1,数字2);这里的数字1表示文件的起点，数字2表示读取的长度。其中数字1和数字2可以缺省。
  如:
  char pic[1600];
  #loaddata pic=load("/LavaData/pic.dat");//会将pic.dat的所有内容载入到pic所指的内存中，缺省了数字1和数字2。
  #loaddata pic=load("/d.dat",16);//会将pic.dat偏移16字节后的所有内容载入到pic所指的内存中，缺省了数字2。
  #loaddata pic=load("/d.dat",16,10);//会将pic.dat偏移16字节后的10字节内容载入到pic所指的内存中。
  #loaddata 0x4000=load("/b.dat");
 使用该命令可以使内存充分利用和加快编译速度。可以用于载入图片等。
*注意:
 1.该命令可以出现在程序的任何地方。
 2.只能初始化全局变量或数字，对局部变量使用该命令会报错。也不能这样写:
  int s[10];
  #loaddata s[0]=1;
  #loaddata s+1={1,2,3};
  以上两种格式都是错误的。
*#code:功能是直接写入虚拟代码。格式是:#code{~};。如:
 #code{0x00};
 #code{10,20,30,20};
 #code{"Hello World!"};
 #code{"sdf",1,3,4};
 code后一定要跟上一对大括号和分号，里面是要写入的虚拟代码，以逗号隔开。该命令再一定程度上扩展了编译器的功能。要实现编译器无法实现的功能时，可以试试这个命令。这种格式有点象变量初始化。
*#begin:设置变量空间地址。编译器在编译程序时，会为每个变量分配一个地址，对变量的操作其实是对地址的操作。众所周知，LavaX的变量空间地址是从0x2000开始的，然后向上生长。用户不能将某个变量与一个地址关联。该命令可以轻易实现这个功能，而不用其他操作(如通过指针等)实现。格式是:#begin 数字。如:
 #begin 0x19c0
 char screenbuf[1600];
 int a=2;
 char b;
 ......
 编译器编译时，会将screenbuf关联到0x19c0上，而a则关联到0x19c0+1600上，依此类推。该命令可以用于需要比较特殊的内存的地址。比如系统定义的特殊内存或io口等。注意该命令容易引起无法跨平台，请适当使用。最好将该命令放在函数外部。
*#end:返回当前地址空间。该命令配合#begin使用，必须与#begin成对出现，并且不能嵌套使用！编译器在遇到#begin命令时，会将当前地址空间备份起来并切换到新的地址空间中。当定义完变量后需要恢复到当前空间中，可以使用#end命令，该命令会将备份恢复到当前地址空间，实现切换功能。格式是#end。如:
 #begin 0x6
 char screenlight;
 #end
 int a=1;
 定义在#begin与#end命令内的变量和全局变量一样可以在定义时初始化。最好将该命令放在函数外部。
#skip:跳过地址空间。因为相邻的变量的地址是相邻的，如:
 int a;
 long b;
 假如变量a的地址是0x2000，那么变量b的地址是0x2002(因为变量a占用2个字节的空间)。
 有时不需要连续的地址，则可以使用#skip跳过该地址而不与任何变量关联。格式是:#skip 数字。如:
 int a;
 #skip 0x10
 long b;
 假如变量a的地址是0x2000，那么变量b的地址是0x2002+0x10了。
#attr:修改属性。格式是:#attr(var,属性列表)。var可以是变量、数字、函数，标号。属性列表有8个属性(t1~t9):
 t1:数组维数n(<=4)
 t2:数组n-1维大小
 t3:类型,具体参见源代码包:'编译/定义.txt'里的特征码
 t4:占用空间字节
 t5:值
 t6:数组n-2维大小
 t7:数组n-3维大小
 t8:数组n-4维大小
 t9:缺省或-1:临时修改属性,非-1:永久修改属性
 如:
 int a;
 #attr(a, -1) = 1;//相当于:a = 1;
 相应的位置为-1时表示不修改该属性。后面不想更改的属性可以不写（但必须有一个属性，不能#attr(a) = 1;）
 #attr可以实现该编译器无法实现的语法:
 1.函数指针。如:
  long a;
  a = fun;//fun为函数地址
  fptr(#attr(a, 1, 0));//表示调用地址为a的值有返回值没有参数的函数（就是把a转换成有返回值没有参数的函数）。
  fptr(#attr(a, 0, 1));//表示调用地址为a的值无返回值1个参数的函数，其余以此类推。
 2.不定参数的函数。如:
 void fun1(char n)//不定参数的函数fun1有且只有一个参数n（值为参数个数）
 {
  #attr(fun1, -1, -1, -1, 7, -1, -1, -1, -1, 0);//修改函数fun1为不定参数函数，其中的7表示该函数（fun1）为void型，如果为8表示long型，最后1个参数表示永久修改属性。
 }
 3.类型转换。如:
 long a = 123456789;
 void main()
 {
  long b;
  int c;
  c=&a;
  b=#attr(0x2000,-1,-1,0,1);//相当于LavaX中的:b=(char*)0x2000;
  b=#attr(0x2000,-1,-1,0,2);//相当于LavaX中的:b=(int*)0x2000;
  b=#attr(c,-1,-1,19,4);//相当于LavaX中的: b=(long*)c;
  b=#attr(c,-1,-1,19,2);//相当于LavaX中的: b=(int*)c;
 }