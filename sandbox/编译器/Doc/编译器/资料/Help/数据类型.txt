*简介:
 LavaX的数据类型如下:基本类型、构造类型。数据由常量和变量之分。在程序中对用到的所有数据都必须指定其数据类型。
*常量:
 在程序运行过程中，其值不能被改变的量称为常量。常量区分为不同的类型，如:
 整型常量:-1,100,0x4000,'a'
  1.十进制常量:123，0。
  2.十六进制常量:以0x开头的数是十六进制数。如:0xff，0x20。
  3.八进制常量:以0开头的数是八进制数。如:0338,0954。
  4.字符型常量:由于字符以ASCII码对应，因此字符也是一个整数。如:'a'，'0'。
 字符串常量:"LavaX"
  字符串常量是一对""号括起来的字符序列。不要将字符型常量与字符串常量混淆。如:'a'是字符常量，"a"是字符串常量，二者不同，因为在字符串中以'\0'（ASCII为0的字符）作为字符串结束标志，所以"a"实际上是'a''\0'两个字符。注意在写字符串是不必加'\0'。
 常量不同于变量，它的值不能改变，也不能被赋值。习惯上，常量名用大写，变量名用小写，以示区别。使用常量的好处是不占内存空间，含义清楚。
*变量:
 其值可以改变的量称为变量。一个变量应该有一个名字，在内存中占据一定的存储单元。在该存储单元中存放变量的值。变量名实际上是一个符号地址，在对程序编译连接时由系统给每一个变量名分配一个内存地址。在程序中从变量取值，实际上是通过变量名找到相应的内存地址，从其存储单元中读取数据。一般，变量名用小写思慕表示，以增加可读性。变量名长度不限，但编译器只取前18个字符，超出部分被截去。
 对所有变量都必须先定义，在使用，否则做未定义处理。如:int student;。以下介绍变量的类型。
*基本类型:
 char:8位无符号整数,范围0~255
 int :16位有符号整数,范围-32768~32767
 long:32位有符号整数,范围-2147483648~2147483647
 数据在内存中是以二进制形式存放的。如：int i;i=10;十进制10的二进制形式为:1010，则变量i在内存中时间存放情况:i:0000000000001010。其中最左边一位时表示符号的，该位为0，表示数值为正，为1则为负。
 前面提到，在程序中所有用到的变量都必须在程序中定义。对变量的定义，一般是放在一个函数的开头部分的声明部分（也可以放在函数中某一位置，但作用域只限在它以下的程序中）。如:
 int max()
 {
  int a, b;

  if ((a = 6) > (b = 3))
  {
   return a;
  }
 }
 一个int型变量的最大允许值为32767，如果在加1会溢出，变为-32768。
*构造类型:
 数组:包括char数组,int数组,long数组
 结构体
 共用体
 1.数组。数组是有序数据的集合，每一个元素都属于同一个数据类型。用一个统一的数组名和下标来唯一地确定数组中的元素。
  一维数组的定义方式为:类型说明符 数组名[常量表达式];，如:int a[2];它表示数组名为a，此数组有2个元素。数组名定名规则和变量名一样。数组名后用[]号，常量表达式不能包含变量。
  数组必须先定义再使用。数组元素的表示形式为:数组名[下标]，下标可以是常量或表达式。如:a[0]=a[i]+a[a+b];
  只有定义为全局（定义在函数外部）的数组才能初始化，如:int a[2]＝{1,2};则对应的:a[0]=1,a[1]=2。可以只给一部分元素赋值，如:int a[2]={2};则:a[0]=2,a[1]=0。在对全部数组元素赋初值时，可以不指定数组长度，如:int a[]={1,2};
  二维数组的定义为:类型说明符 数组名[常量表达式][常量表达式];，我们可以把二维数组看作是一种特殊的一维数组，它的元素又是一个一维数组。如:int a[2][2];。二维数组元素的表示形式为:数组名[下标][下标]。如果对全部元素都赋初值，则定义数组是对第一维的长度可以不指定，但第二维的长度不能省，如:int a[][2]={1,2,3,4};。本编译系统最多支持4维数组。
 2.结构体。有时需要将不同类型的数据组合成一个有机的整体，以便于引用。这时可以将其定义为结构体，如:
 struct std
 {
  char name[20];
  int sex;
 };
 注意不要忽略最后的分号。上面指定了一个新的结构体类型struct std（struct是声明结构体类型时所必须使用的关键字，不能省略），它向编译系统声明这是一个结构体类型，包括name、sex不同类型的数据项。应当说明struct std是一个类型名，它和系统提供和标准类型（int、char、long）一样具有同样的地位和作用，都可用来定义变量的类型。声明一个结构体类型的一般形式为:
 struct 结构体名
 {
  成员表列
 };
 注意类型和变量是不同的概念，在编译时，对类型不分配空间。成员也可以是一个结构体变量。
 先声明结构体类型再定义变量名。如上面已定义了struct std，可以用它来定义变量。如:strcut std std1;定义了std1为struct std类型的变量。在定义后，系统会为之分配内存单元。如:std1在内存中占22个字节。
 可以在声明时定义变量，如:
 struct std
 {
  char name[20];
  int sex;
 } std1;
 它的作用与第一种相同。其一般形式为:
 struct 结构体名//结构体名可以缺省
 {
  成员表列
 } 变量名表列;
 引用结构体变量中成员的方式为:结构体变量名.成员名。如果成员本身有属于一个结构体类型，则要用若干个.号一级一级地找到最低一级的成员。如:std1.num，a.b.c;
 3.共用体。有时需要使几种不同类型的变量存放到通一段内存单元中，也就是使用覆盖技术，几个变量互相覆盖，这种结构称为共用体。
 定义共用体类型变量的一般形式为:
 union 共用体名
 {
  成员表列
 } 变量表列;
 在定义，引用上与结构体一样，只是关键字改为union而已。
 结构体变量所占内存长度是各个成员占的内存长度之和。每个成员分别占有其自己的内存单元。共用体变量所占的内存长度等于最长的成员的长度。
 共用体有以下特点:
 1.同一个内存段可以用来存放几种不同类型的成员，但在每一瞬间只能存放其中一种。
 2.共用体变量中起作用的成员是最后一次存放的成员。
 3.共用体变量的地址和它的各成员的地址都是同一地址。
*引用。引用的作用是为一个变量起一个别名。假如有一个变量a，想给它起一个别名b，可以这样写:int a;int &b=&a;（注意与c++的区别），这就声明了b是a的引用，即a的别名。经过这样的声明后，使用a或b的作用相同，都是代表同一个变量，但b的本质是指针。因为b的本质是指针，所以b要占用空间（2字节），所以要用&取地址符把a的地址赋给b。在函数执行期间，b可以作为其它变量的引用，比如:在程序后面又定义的变量c，int c;可以使b作为c的引用：&b=&c;。由此，我们总结：int &b=&a;那么b相当于变量a，&b即可以看作引用b本身，也可以看作a的地址，*b则相当于*a，如果&(&b)则是引用b的地址！（不可写成&&b！）。引用也可以作为函数的参数使用。
 举个例子:
#include <stdio.y>
#include <malloc.y>
struct student
{
 char name[20];
 int score;
 struct student &next;
};
void main()
{
 int i, n;
 struct student& p, q, head = 0;

 SetScreen(0);
 scanf("Input member:", "%2d", &n);
 for (i = 0; i < n; i++)
 {
  &p = malloc(sizeof(struct student));
  if (!(&p))
  {
   printf("内存分配失败！\n");
   getchar();
   return;
  }
  scanf("name:", "%20s", p.name);
  scanf("score:", "%2d", &p.score);
  if (!(&head))
  {
   &head = &p;
  }
  else//这里&p,&head都看成引用本身（本质是指针）
  {
   &q.next = &p;
  }
  &q = &p;
  &p.next = NULL;
 }
 &p = &head;
 while (&p != NULL)
 {
  printf("name:%s score:%d\n", p.name, p.score);
  getchar();
  &q = &p;
  &p = p.next;
  free(&q);//释放空间
 }
}
*局部变量
 在一个函数内部定义的变量是内部变量，它只在本函数范围内有效，也就是说只有在本函数内才能使用它们，在此函数以外是不能使用这些变量的。这称为局部变量。如:
int f1(int a)
{
 int b, c;
 ...
}
char f2(int x, int y)
{
 int i, j;
 ...
}
void main()
{
 int m, n;
 ...
}
 说明:
 1.主函数main中定义的变量m，n也只能在主函数中有效，而不因为在主函数中定义而在整个文件或程序中有效，主函数也不能使用其它函数中定义的变量。
 2.不同的函数中可以使用相同的名字的变量，它们代表不同的对象，互不干扰。如，在f1函数中定义了变量b，c，倘若在f2函数中也定义了变量b，c，它们在内存中占不同的单元，互不混淆。
 3.形式参数也是局部变量。如f1函数中的形参在f1函数中有效。其它函数不能调用。
*全局变量
 在函数内部定义的变量是局部变量，而在函数之外定义的变量是外部变量，外部变量是全局变量。它的有效范围为从定义变量的位置到本源程序结束。全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元。
*static
 有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，在下一次该函数调用时，该变量已有值，就是上一次函数调用结束时的值。这时就应该指定该局部变量为静态局部变量，用关键字static进行声明。如：static long a;
 1.静态局部变量属于静态存储类别，在静态存储区内分配存储单元。在程序整个运行期间都不释放。而局部变量属于动态存储类别，占动态存储区空间而不占静态存储区空间，函数调用结束后即释放。
 2.对静态局部变量时在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上一次函数调用结束时的值。而对局部变量赋初值，不是在编译时进行的，而是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。
 3.如在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0。而对局部变量来说，如果不赋初值则它的值是一个不确定的值。这时由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的存储单元中的值是不确定的。
 4.虽然静态局部变量在函数调用结束后仍然存在，但其它函数是不能引用它的。
*注意:
 1.LavaX本质上是无类型的语言。数据的内容，可以是整数，也可以是内存地址。
 2.局部变量不能与全局变量同名，自定义函数不能和系统函数重名。
 3.结构体和公用体不能在定义时初始化，且只能对成员一个一个的初始化，比如：
 struct TT
 {
  int a;
  long b;
 } data = {0, 2};
 或
 struct data = {1, 2};
 这两种写法都是不对的。应该这样：
 struct TT
 {
  int a; 
  long b;
 };
 struct TT t;
 void main()
 {
  t.a = 1;
  t.b = 2;
 }
 注意与C/C++语言语法的区别。